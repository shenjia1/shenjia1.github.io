<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[变异检测（三）之点突变检测]]></title>
    <url>%2F2020%2F08%2F09%2F20200814%2F</url>
    <content type="text"><![CDATA[引言点突变和插入删除突变是比较常见的变异类型。所谓点突变就是简单的单个碱基的替换，插入删除突变是一个及一个以上碱基的删除或插入，在比对上就是会引入空位。这样的突变的检测，理论上来说在比对结果中可以被识别。但是由于背景噪声的存在，经常需要应用统计学的方法进行去噪声，然后才能对真正的变异进行识别。这样的统计学方法在处理体细胞突变的检测问题中显的尤为重要。因为体细胞突变的突变频率有时往往很低，隐藏在背景噪声中，很难被发现。为此，科学家开发了很多针对性的软件解决这个问题，如Mutect，VarScan等等。近年来，也有科学家将深度学习的算法引入到突变的检测识别方法中来，主要是由于基因数据积累的越来越多，可以通过深度学习的方法将真实突变从复杂的噪声中识别出来，这样的方法也取得了比较好的效果，比如GATK4中就引入了深度学习的方法进行变异位点的过滤。 针对插入删除变异的检测识别问题，同样存在一个难点，那就是比对的问题。复杂的插入删除突变有时在比对会与原序列出现很大差异，这给比对造成很大困难，而造成检测识别的失败。针对这个问题，科学家也开发了很多针对性的算法，如重比对，局部组装等等。 算法简介点突变的检测简单的来说，点突变的检测主要是一个分类问题，以体细胞突变的检测识别为例，这个检测识别主要是区分真实突变与背景噪声，其中背景噪声包括“比对错误”，“测序错误”，“遗传性变异”等等。不同的噪声有其一定的特征，比如可以根据测序质量及链偏向性去估计测序错误的可能性。其实，这就是一个统计学上的分类问题。既然是一个分类问题，那么就可以使用很多统计学的分类算法去解决它。下面，我举几个例子，他们是比较著名的软件中使用的统计学方法，主要会介绍他们的算法，并介绍他们选择的特征。 很多软件都使用的是贝叶斯算法。下面，我就以一个经典的体细胞变异检测的软件的算法为例，简单介绍下贝叶斯公式在变异检测中的应用。所谓的贝叶斯公式是基于条件概率的统计学方法。贝叶斯公式中，事件Bi的概率为P(Bi)，事件Bi已发生条件下事件A的概率为P(A│Bi)，事件A发生条件下事件Bi的概率为P(Bi│A)。MuTect软件包含了两个贝叶斯分类器，第一个是区分该位置是否发生突变，第二个是区分该变异是否为体细胞变异。 第一个贝叶斯分类器下面，我们首先介绍第一个贝叶斯分类器。首先，我们设定是某个位置，然后开始使用这个分类器去区分这个位置是否发生突变。r表示参考基因组：{A,T,C,G}b表示该位点的碱基：{A,T,C,G}e表示该位点的质量，也就是发生测序错误的可能性，它的计算方法与该碱基的测序质量Q有关。e等于10的-q/10次方。假设了两个模型：M0:该位点没有发生突变，所有与参考基因组不一样的碱基都是测序错误；Mf：该位点发生了突变，且突变频率是f，M0其实等于f=0的Mf。 下面我可以计算M的似然：LOD(M) = P(bi|ei,r,m,f)的积其中每一个bi都是每i个reads比对到该位置碱基，ei是该碱基的质量。计算出得到P，具体计算方法如下： 如果bi是参考基因组的碱基类型，那么 P = f * ei/3 + (1-f)(1-ei) 意义: 因为该位点的突变频率是f，所以说明有f的碱基是非参考基因组的碱基类型，但bi是参考基因组的碱基类型，所以f的碱基是测序错误，而其他的1-f的碱基是没有测序错误的，其中ei的概率是测错的，那么某个碱基类型的测错的概率就是ei/3. 如果bi不是突变的碱基类型，那么 P = (1-f) * ei /3 + f(1-ei) 如果bi是其他的情况，那么： P = ei / 3 m是突变的碱基类型，也就是有除了参考基因组碱基类型外还有三种碱基类型。需要比较两个模型的似然，才能识别该位点是否发生突变： LOD(m,f) = log10(L(Mf)P(m,f)/L(M0)(1-P(m,f))) 如果LOD(m,f)大于log10Qt，那么就认为m是一个突变碱基。Qt在MuTect最初的文献中被设定为6.3，表示该位点突变的置信度是背景噪声的6.3倍以上。根据以上的公式，现在可以区分该位点是否存在突变。其中P(m,f)与f的值还未知，P(m,f)可以通过P(m)和P(f)计算得到，假设两者是统计学上独立的，P(f)是均一分布，P(f) = 1,P(m)是一个经验值，文献中将它设置为 3 × 10−6。针对f的值，可以通过最大似然估计计算得到，也可以通过突变碱基数处理总测序深度得到。 第二个贝叶斯分类器第二个贝叶斯分类器是用于区分遗传性突变和体细胞突变的。基本的模型与第一个分类器类似，其中f被设置为0.5，因为理论上遗传性突变是杂合的。 LOD(N) = log10(L(M0)P(m,f)/L(M0.5)P(germline)) 就是只有大于log10Qn时才被认为是体细胞突变。其中P(germline)和Qn阈值设定如下： P(germline|non-dbSNP site) = 5 × 10−5 Qn|non–dbSNP site = 2.2 P(germ line|dbSNP site) = 0.095 θn|dbSNP site = 5.5]]></content>
      <tags>
        <tag>SNP变异，检测软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变异检测（二）之CNV检测]]></title>
    <url>%2F2020%2F08%2F06%2F20200806%2F</url>
    <content type="text"><![CDATA[引言上篇说到CNV检测方法已经有很多了，并且不同的检测方法适用于不同类型的测序数据。针对WES，WGS，Panel，SNParray或Single Cell数据，人们开发了不同的拷贝数变异检测方法。当然总的来说，所有的方法都会包含上篇说的几个步骤，但是不同方法会使用不同的算法去解决这几个步骤的问题。下面我会汇总拷贝数变异检测的软件，罗列各个软件的开发语言，适用的数据类型，以及软件下载路径和参考文献。 软件汇总 软件名称 适用数据类型 开发语言 软件下载路径 参考文献 CNVkit WGS/WES Python cnvnator WGS C++ CNVnator canvas WGS C# Canvas gatk-cnvcaller WGS/WES Java cn.MOPS WES R ERDS WGS Perl ERDS cnv-seq WGS Perl CNVseq Increment_Ratio_of_Coverage WGS Perl CNVseq GWCNV WGS GWCNV CNVPanelizer WES R CNVPanelizer DECoN WES R DECoN Pubmed CONTRA WES CONTRA Atlas-CNV WES R Atlas-CNV panelcn.mops Panel R panelcn.mops ximmer DeviCNV WES Python DeviCNV Genome STRiP WES Genome STRiP XHMM ExomeCNV WES ExomeCNV ExomeCopy WES ExomeCopy ExomeDepth WES ExomeDepth CoNIFER WES CoNIFER cnvOffSeq WES cnvOffSeq ClinCNV WES/WGS ClinCNV HoneyBADGER SingleCell aneufinder SingleCell CNVetti SingleCell Rust PennCNV SNParray C PennCNV 持续更新中……]]></content>
      <tags>
        <tag>学习资料，拷贝数变异</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变异检测（一）之CNV检测]]></title>
    <url>%2F2020%2F08%2F05%2F20200805%2F</url>
    <content type="text"><![CDATA[引言变异检测是人类基因组重测序过程中，比较重要的一个步骤。我们使用比对软件将二代测序得到的短序列映射到人类的参考基因组上之后，便是需要进行变异检测。所谓变异，分为点突变，插入删除，拷贝数变异，结构变异等等。不同变异的检测方法不同，当然针对不同类型的测序数据，也需要使用不同的检测方法。点突变的检测相对比较简单，需要从比对结果中找突变的位置，并通过统计学算法区分测序错误，比对错误和真实变异。 拷贝数变异也是一种变异类型，对拷贝数变异的检测，与点突变的检测方法不同。假设测序得到的短序列在整个参考基因组上分布均匀，那么如果所有区域拷贝数都是正常的话，那么所有区域的分布的序列数都一致。如果某个区域的分布的序列数出现异常，那么可以得到该区域的拷贝数出现了异常。正是根据这个假设，人们开始设计不同的基于测序覆盖度的拷贝数检测算法。 根据不同的测序数据，可以分为全基因组拷贝数检测方法，全外显子组拷贝数检测方法。根据不同的检测目的，可以分为遗传性拷贝数变异检测方法，癌症基因组拷贝数检测方法。拷贝数检测软件有很多，具体的软件的列举，我会在另一篇文章中进行总结和介绍，下面我主要介绍几类拷贝数检测方法中涉及到的算法。 拷贝数变异检测算法一、全基因组检测方法（1）划分窗口一般会根据测序深度进行窗口的划分，窗口划分的大小会影响CNV检测的大小。一般来说，测序深度越深，检测到的CNV的大小的下限就越小。所以窗口大小的划分对检测结果是影响很大的。针对（0.5-1.5X）低深度的全基因测序，我们通常使用50kb的窗口滑动，滑动距离是5kb，这样的窗口设置也可以检测到1M左右的拷贝数变异，甚至是1M以下的。 （2）统计每一个窗口的序列计数或平均深度根据设定的窗口，计算每一个窗口的序列计数或者平均深度，这个是判断该区域是否存在拷贝数变异的重要指标。 （3）对计数或深度进行校正虽然我们做了全基因组序列分布均匀的假设，但是根据实际数据分析，某些区域因为某些原因，会出现序列分布不均匀的现象，这些现象的发生与拷贝数变异无关，而与一些序列特征有关，如GC含量等。发现了这个问题，一般算法都会对计数或测序深度进行GC校正或其他校正。校正的方法有很多，中位数校正，拟合回归校正等等。 （4）对完成校正后的数据进行CNV检测这种CNV检测方法有很多，比如circular binary segmentation算法，HMM算法，或者直接设定阈值的简单算法。 根据以上的四个步骤，即使不使用参照集（或者说是外部参照），也可以进行CNV的检测。 二、全外显子组检测方法全外显组拷贝数变异的检测与全基因组的最大的不同就在于之前的假设上，全外显组靶向捕获技术由于捕获效率的不同，导致不同的目标区域获取的序列数目是不同的，即使是同一个panel，不同时间不同人员的操作，可能都会对捕获效率有所影响，这就造成了拷贝数变异检测的困难。在这样的情况下，人们不得不使用外部参照，通过参照集的比较，找到异常的区域，从而发现CNV。 拷贝数检测几个相关问题（1）序列数和平均测序深度我认为统计序列数和平均深度差异并不是很大，可能在测序深度很深情况下，对于较小的CNV检测是会有影响，因为两者在区域边缘处理上会有所差异。 （2）参照集的选择参照集的选择建议尽量选择同一个实验批次的样本，最为合适。这里对于全外显子组数据要求更高。 （3）杂合子分析由于拷贝数的变化也会引起该区域内杂合子的缺失，所以有时杂合子的缺失也是拷贝数变异的一个佐证，在分析过程中，有的算法也会把这部分的信息考虑进来。 三、全基因组拷贝数检测方法Go实现（CNVgo）解决难点： GC校正方法：中位数校正，回归校正 并行计算覆盖度或reads数目 区域识别，CBS算法实现，HMM算法实现 非整倍体识别 批量检测，固定参照集，无参照集 计划算法： 并行快速计算覆盖度，输入文件是bam文件； 去除同源区域或异常区域 将窗口大小，滑动大小设置为参数 多种校正方法选择，多种识别方法选择 兼容非整倍体识别 可选对照集 绘制必要的图表]]></content>
      <tags>
        <tag>基因注释，基因</tag>
        <tag>Annovar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列比对（四） 启发式比对之BWT算法]]></title>
    <url>%2F2020%2F07%2F31%2F20200803%2F</url>
    <content type="text"><![CDATA[引言由于精确比对在处理数据量较大的序列比对问题时，耗时比较长，所以需要一些更快速的比对算法。比如之前为了解决数据库搜索问题，而产生的BLAST算法。我们今天介绍的BWT算法也是为了解决一个精确比对无法解决的问题，或者说在短时间内无法解决的问题。那就是短序列比对到特长序列上，如二代测序数据比对到人类基因组上。由于人类基因组序列长度很长，如果使用精确比对，一条短序列的比对就会耗时很久。这样就必须需要一种快速的比对方法来解决这个棘手的问题。目前二代测序常用的软件也是基于BWT算法的，比如BWA，Bowtie等等。BWT算法原本是用于数据压缩的，在数据压缩上效率很高。下面我会根据我的理解，基于BWA软件的文章，简单介绍下BWT算法，包括，BWT转换，以及具体的比对方法。 算法简介（一）BWT转换1.BWT编码原始序列： ACCGCGCGT 加入$作为序列尾部字符： 0 ACCGCGCGT$1 CCGCGCGT$A2 CGCGCGT$AC3 GCGCGT$ACC4 CGCGT$ACCG5 GCGT$ACCGC6 CGT$ACCGCG7 GT$ACCGCGC8 T$ACCGCGCG9 $ACCGCGCGT 按字典表排序： 0 9 $ACCGCGCGT1 0 ACCGCGCGT$2 1 CCGCGCGT$A3 2 CGCGCGT$AC4 4 CGCGT$ACCG5 6 CGT$ACCGCG6 3 GCGCGT$ACC7 5 GCGT$ACCGC8 7 GT$ACCGCGC9 8 T$ACCGCGCG BWT序列，就是排序后的矩阵的最后一列字符。 T$ACGGCCCG 如果对BWT序列进行一定的压缩，如T$AC2G3CG，就可以起到很好的压缩效果。 2. BWT解码可以通过BWT序列（以下成为L列）和排序后矩阵的第一列序列(以下成为F列)，就可以还原原序列，具体的解码如下：我们需要从L列的第一个字符开始，由于$字符是在所有字符之后，所有BWT序列的第一个字符一定是原序列的最后一个字符，所以我们由此开始 T –&gt; 找到F列中第一个T的位置即（9），则从（9）中发现在L中的相应序号的位置的字符是G，即为T在原序列的前一个位置的字符 以此类推，就可以还原原序列。 解码伪代码： def LF(r): c = BWT[r] return C(c) + Occ(c,r) + 1 def BWT_reverse(): r = 1 T = "" while (BWT[r] != "$"): T = T + BWT[r] r = LF(r) return T 其中，C[c]的定义是，字典序小于字符c的所有字符个数。Occ[c,r]表示在BWT（T）中第r行之前出现字符c的个数。 （二）LP查询，精确匹配也就是根据查询序列从参考序列中找到相应的比对位置。大致的思路与上面的解码类似，只是开始搜索的位置需要从F列开始，根据查询序列的最后一个字符在F列中的位置（一般会有多个位置）开始不断往前匹配，从而找到相应的位置。 精确匹配伪代码： def LF(c,r): return C(c) + Occ(c,r) + 1 def exactmatch(Q[1,q]): c = Q[q] sp = C[c] + 1 ep = C[c+1] + 1 i = q - 1 while (ep > sp) and (i > 0): c = Q[i] sp = LFC(c,sp) ep = LFC(c,ep) i = i - 1 return sp, ep 其中，c+1表示字典序比字符c大的下一个字符。 （三）小结在具体算法实现过程中，比如软件BWA和Bowtie等，还会考虑内存和效率上的取舍，选择合适的方案，主要优化点在提前计算好一些数据，如C[c],Qcc(c,r)以及相应的位置信息等等，当然考虑到内存消耗也不会完全储存，会储存简化版。也会考虑mismatch和indel等等匹配。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>BWT，BWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列比对（三） 启发式比对之BLAST搜索算法]]></title>
    <url>%2F2020%2F07%2F30%2F20200730%2F</url>
    <content type="text"><![CDATA[引言全局比对和局部比对都是精确比对，在两条序列比对时，使用精确比对是可行的，并且我们也会在较快的时间内得到最佳比对。但是在生物序列分析中，往往会遇到一些序列搜索问题。比如在蛋白质结构预测问题中，需要快速的从模板库中找到查询序列的模板；搜索微生物序列库，确定某段序列或某些序列是属于哪些微生物的。总而言之，我们会遇到生物序列库的搜索问题。当然，我们也可以使用全局比对或局部比对，使用查询序列与数据库中的每条序列进行比较，从而计算最大的比对得分，最后找到最佳比对。但是这样的搜索随着序列数据库中序列数目的增多，耗时也会增加。最后，我们无法在预计的时间内得到结果。为了加快搜索速度，启发式比对的算法诞生了。启发式比对，并不会对全部序列都使用精确比对，而会使用一些策略，确定最有可能的一些序列，然后针对这些序列再使用精确比对，这样就极大地缩减了搜索的耗时。 算法介绍BLAST方法是基于FASTA方法的优化得到的，FASTA方法和BLAST方法类似，也是一种启发式的序列搜索算法。它是通过相同片段的查找，计算得分矩阵找最佳比对的。BLAST是考虑了氨基酸序列的特殊性，所以将相等片段修改为相似片段。所谓相似片段就是根据PAM250等得分矩阵计算的两个序列的得分大于某个值的片段。 （1）找到命中点首先将查询序列切分成固定长度的片段，如果是氨基酸序列，一般是3-5个氨基酸长度，如果是DNA序列，一般取12个碱基。切分完成后，为每一个小片段确定相似片段。每一个小片段与所有可能的情况进行计算，得分大于某个值的片段，就是这个小片段的相似片段。然后，在数据库序列上搜索这些相似片段的位置，这些位置信息就是所谓的命中点。其中，确定相似片段集这步可以提前完成。 （2）延伸命中点对于包含命中点的数据库序列，我们会进行延伸，延伸得到的打分大于某个阈值时，该片段被成为高得分片段。在延伸中，如果得分下降不超过某个阈值，那么延伸不停止，如果超过了，就终止。 （3）根据得分，将得分排在前面的序列与查询序列进行精确比对，得到搜索结果以上是最初BLAST的基本算法，思路比较简单，但是效率确实提高了很多。在此之后，BLAST算法也经过了很多的优化，在效率和精度上都有很大的提升。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>BLAST，启发式搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列比对（一） Needleman-Wunsch算法]]></title>
    <url>%2F2020%2F07%2F23%2F20200724%2F</url>
    <content type="text"><![CDATA[引言序列比对是生物信息学的经典问题。为了解决生物序列比对的问题，人们已经开发了很多算法，其中包含精确比对，以及为了优化比对速度而诞生的启发式比对算法等等。Needleman-Wunsch算法是一种全局比对算法，也就是会考虑两条序列的所有碱基的比对算法，如下： ATCGGGGGGGGG---GGGGGGCGCG AT-GGGGGGG--CCC------CGCG 算法介绍（1）建立得分矩阵所谓得分矩阵，就是用于序列比对时计算比对得分，比对得分越高，就说明该比对越接近最优比对。根据比对的不同情况可以分为：完全匹配，错误匹配，插入空位三种情况。针对这三种不同的比对情况，我们可以根据得分矩阵进行打分处理。 下表是一个得分矩阵的例子： 0 A T C G 0 0 -2 -2 -2 -2 A -2 1 -1 -1 -1 T -2 -1 1 -1 -1 C -2 -1 -1 1 -1 G -2 -1 -1 -1 1 以上只是一个比较简单的例子，没有根据生物学序列的具体问题进行设计。比如：根据不同碱基的错误匹配，可以给出不同的打分，当然这个针对氨基酸序列的比对更有意义；插入空位的情况在生物学序列中的出现的概率要比错误匹配的概率低很多，那么根据这个生物学特性，可以将插入空位的罚分设的更低。 （2）初始化相似性分数矩阵假设有两条待比对的序列，根据得分矩阵计算每一个碱基之间的相似性分数，从而构建相似性得分矩阵，以(D序列)ACGCG和(Q序列)CCGACC两条序列为例： - A C G C G - 0 -2 -2 -2 -2 -2 C -2 C -2 G -2 A -2 C -2 C -2 根据上面的得分矩阵，可以得到碱基与空位的相似性分数为-2，所以把对应位置的相似性分数初始化为-2. （3）根据下面的逻辑计算各个位置的相似性得分为了计算某个位置的相似性分数，需要考虑三个方向，横向，纵向和对角线。三个方向，其实是针对某个比对位置的三种比对方式，选择分数最大的一种比对方式。比较好理解的是对角线方向，也就是直接匹配。横向和纵向都是插入空格。 对角线： V(i,j) = v(i-1,j-1) + F(D[i],Q[j]) 横向: V(i,j) = v(i-1,j) + F(D[i],-) 纵向：V(i,j) = v(i,j-1) + F(-,Q[j]) 选择以上三种计算方式得到的最大相似性分数作为该位置的相似性分数。以此方法填充得到完整的相似性得分矩阵。 （4）通过回溯法，找到最佳比对，并得到最高得分从相似性得分矩阵的右下角向上回溯，每次取三个方向的最大值作为走向，找到最佳比对，输出比对。 以上是Needleman-Wunsch算法的整体思路，它主要思路是基于动态规划法。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>序列比对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列比对（二） 局部比对算法以及两种空位插入的优化策略]]></title>
    <url>%2F2020%2F07%2F23%2F20200727%2F</url>
    <content type="text"><![CDATA[引言上篇讲的Needleman-Wunsch算法是一种全局比对算法，也就是会将两条序列的所有部分都考虑进来。但针对短序列比对到长序列时，这种全局比对算法就不太合适了。也就是说，我们需要一种序列比对算法可以解决这种局部比对的问题。其实局部比对算法可以说是，全局比对算法的一种变型，下面我们来介绍具体的算法，Smith-Waterman算法。同时，也会介绍两种优化的策略：末端空位自由比对和空段罚分比对。这两种策略都是对于空位的插入罚分的优化，可以让空段合理连续插入并且可以在首位和末尾插入。 算法介绍（1）Smith-Waterman算法Smith-Waterman算法与Needleman-Wunsch算法的步骤基本一致，主要在以下三个方面做了调整： 1.初始化相似性分数矩阵时，与空位的相似性分数都为0；2.计算相似性分数，考虑三个方向的最大值时，最小值为0；3.回溯时，遇到0则停止。 （2）末端空位自由比对末端空位自由比对与全局比对算法一致，主要在以下方面做了调整： 1.初始化相似性分数矩阵时，与空位的相似性分数都为0；2.回溯时，从最后一列和最后一行的最大值开始回溯。 （3）空段罚分比对空段罚分比对主要是在迭代计算相似性分数方法上进行了优化，在空段罚分时，考虑了该位置周围的比对情况，对相应的位置的罚分进行了校正。其中，在考虑空段时，插入空位和空位延伸给予了不同的罚分，Ws表示空位插入的罚分，Wg表示的是空位延伸的罚分，所以在初始化的过程中就会考虑空位的延伸问题，而不是将每一个空位的罚分都设为固定值。 具体迭代计算规则如下： V(i,j) = Max(M(i,j),E(i,j),F(i,j))M(i,j) = Max(M(i-1,j-1)+S(D,Q),E(i-1,j-1)+S(D,Q),F(i-1,j-1)+S(D,Q))E(i,j) = Max(M(i,j-1)+Ws+Wg,E[i,j-1]+Ws)F(i,j) = Max(M(i-1,j)+Ws+Wg,F(i-1,j)+Ws) 总结以上算法介绍部分的（2）和（3）是比对中引入的两种策略，这两种策略可以添加到全局比对和局部比对中去，都是对空位的处理方式的一种优化。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>序列比对，局部比对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生物信息学与GO语言]]></title>
    <url>%2F2020%2F07%2F22%2F20200722%2F</url>
    <content type="text"><![CDATA[生物信息学是一门工具性的学科，主要是编写，使用软件去解决生物学问题。换句话说，生物信息学是一门关于数学，统计学，生物学的交叉学科。为了解决具体的生物学问题，目前已经有了许多优秀的生物信息学算法和软件。这些软件有的是使用perl写的，比如Annovar等；有的是使用C/C++写的，比如bwa等；有的是使用Python写的，比如cnvkit等，也有使用Java编写的，如Exomiser等。已有的软件经过了使用者和开发者的测试使用验证，在准确性上都有了很高的保证。在这种情况下，有的生物信息学分析步骤已经比较成熟了，也已经有了规范，一般我们不需要自己从头开发软件去解决问题，只需要使用脚本语言组合现有的软件搭建合适的流程去解决问题，因为现有的工具已经足够了。但是，同时也有一些方面，现有的软件并不能很好的解决，或者说这个解决问题的方法比较个性化，这个时候就需要我们自己造轮子了。所以，我认为不管是已经有了优秀软件的，还是还没有合适软件的，我们都要尝试自己造轮子，去解决具体的生物学问题，这样对使用生物信息方法解决问题这件事会有自己独特的理解。我们以最基础的生物信息问题举例，序列比对问题。序列比对，简单来说是一个字符串匹配的问题。一般来说，分为以下几种情况：短序列比对到长序列；短序列比对到一组长序列；多序列比对；长序列比对。解决不同的情况，需要应用不同的算法，即使使用现有的比对软件，也需要使用不同的参数。所以如果不了解其中的具体算法，是很难真正解决一个生物学问题的。上面也提到了，生物信息软件可以使用各类不同的编程语言，使用较多的应该是perl，python，C/C++.Perl语言在字符串处理方面有独特的优势，且它又是脚本语言，开发速度比较快，在生物信息学中使用广泛。Python语言具有广泛的第三方库，在需要使用一些统计学算法时，不需要从头编写，直接可以使用三方库即可实现，开发速度快且方便，近年来有取代perl的趋势。C/C++主要在解决一些性能要求比较高的问题时需要，但是相对开发速度较慢。GO语言是由Google开发的编译型语言。语法与C语言类似，学习曲线平缓，容易上手，代码也易读。开发效率和运行效率表现都很好。如果使用GO语言对一些已有的软件进行重构，可能是一件有趣的事情。既可以学习使用GO语言去解决生物学问题，又可以对具体的生物信息学算法有一个全面的认识，我觉得这不失为一种有效的学习方法。下面是我具体的一个计划： （1）序列比对：精确比对：NW算法的实现，SW算法的实现启发式比对：BLAST算法的实现其他比对：BWT比对算法的实现多序列比对算法的实现（2）变异检测：SNV检测：遗传性变异检测算法的实现，体细胞变异检测算法的实现Indel检测：重比对检测算法的实现，局部组装检测算法的实现CNV检测：Exon CNV检测算法的实现，全基因组CNV检测算法的实现SV/FUSION检测：Split reads重比对检测算法的实现，DNA/RNA分析算法的实现（3）变异注释：Annovar软件算法的实现（4）基因表型分析软件Exomiser的基本算法介绍（5）ACMG自动化SNV/CNV自动化分类（6）其他：UPD/LOH检测算法的实现HLA分型性别计算可视化交互界面的实现流程构建框架TMB的计算MSI的分析以上计划是一个比较庞大的项目，每一个算法，我都会选择一个或多个现有的软件进行分析，在此基础上使用GO语言对算法进行简单重构，主要目的是为了理解算法，当然在理解算法的基础上，能对现有的算法进行优化，那是最好的结果。]]></content>
      <tags>
        <tag>GO</tag>
        <tag>生物信息</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链学习笔记（二）]]></title>
    <url>%2F2018%2F03%2F19%2F20180320%2F</url>
    <content type="text"><![CDATA[0. 说在前面今天打算把这两天从《精通比特币》这本中了解的两种算法记录下来，希望我以及和我一样的数学小白能理解这两种算法的意义。简单的概括一下，椭圆曲线方程算法是一种从私钥生成公钥的非对称加密技术，是密码学的一种算法；哈希二叉树是区块链中存储交易记录的一种高效的数据结构，它结合了哈希表与二叉平衡树，使得验证交易的时间随交易数量增加上升得很慢。下面我会尽可能白话地讲解这两个知识点，本身他们不存在什么联系，我只是在看了前半本书后，对这两个知识点记忆比较深刻，同时也是比较懵懂的情况下，查了一些书籍，根据一些博客的介绍，才对这两个知识点慢慢有了一定的了解，要原谅一个小白的学习效率。 1. 椭圆曲线方程椭圆曲线方程这篇博客讲的很详细，我只是在理解它的基础上加以解释。接下去，我会按照我理解的逻辑描述椭圆曲线方程。简单的来说，椭圆曲线方程的存在，是为了构建一类数，这类数满足我们设定的四则运算，比如自然数，实数。所以椭圆曲线方程是构建这类数的一个工具，是为了使这类数的四则运算很难逆转，也就是无法从结果推知计算过程。 射线平面坐标系其实，椭圆曲线方程与椭圆无关，他是一种直角坐标系中的曲线，是由满足每个方程的点对组成。为了使构建的数域更加的完成，我们首先要引入射线平面坐标系。在学习平面几何的时候，我们都知道两条平行线永不相交，这是没有给出证明，也就是说这是一个公设，那为什么不能认为两个平行线相交于无穷远点。所谓无穷远点，也是构建出来的（数学就是这么多假设，这么多设想，想想多少星星是数学算出来的，好可怕）。 无穷远点有如下定义： 每条直线上只有一个无穷远点； 同一平面上的平行线有相同的无穷远点； 相交的直线的无穷远点不同； 平面上所有无穷远点构成一条直线； 射影平面包括无穷远点和平常点。 我们都知道，平面上的曲线都是可以用方程来表示的，那么射影平面中椭圆曲线也是可以用方程来表示，椭圆曲线就是一群在射影平面上满足威尔斯特拉斯方程（Weierstrass）点。 $Y^2Z+a_2XYZ+a_3YZ^2=X^3+a_2X^2Z+a_4XZ^2+a_6Z^3$ 椭圆曲线上每一个点都必须是光滑的，也就是有切线，当Z为零时，就是无穷远点。Z不为零时，椭圆曲线方程上的点称为平常点，所以每一个平常点都有切线。 有没有可能通过一种运算方法把椭圆曲线上的点联系起来，这在数学上称为群，也就是说可以曲线上的点可以通过曲线上的其他点应用这种四则运算得到。由此，我们定义了椭圆曲线加法。任意取椭圆曲线上两点P、Q（若P、Q两点重合，则作P点的切线），作直线交于椭圆曲线的另一点R’，过R’做y轴的平行线交于R，定义P+Q=R。这样，加法的和也在椭圆曲线上，并同样具备加法的交换律、结合律。 到这里，我们在射影平面上构建了椭圆曲线，并且在椭圆曲线上构建了一个数群。但是这个数群时连续的，连续的数群时无法用来加密。 有限域的椭圆曲线方程所谓有限域的理解，其实很简单就是只选择椭圆曲线上的部分点，将曲线上的所有点除以某个素数p然后取其余数，这样，椭圆曲线上的数组成了一个p阶的数域。并且这个数域中的所有数都符合先前建立的四则运算。这样，有限域的椭圆曲线方程便建立，并且是一个离散的形如自然数的数据集。 下面，我们给出一个有限域Fp，这个域只有有限个元素。 Fp中只有p（p为素数）个元素0,1,2 …… p-2,p-1； Fp 的加法（a+b）法则是 a+b≡c (mod p)；即，(a+c)÷p的余数 和c÷p的余数相同。 Fp 的乘法(a×b)法则是 a×b≡c (mod p)； Fp 的除法(a÷b)法则是 a/b≡c (mod p)；即 a×b-1≡c (mod p)；（b-1也是一个0到p-1之间的整数，但满足b×b-1≡1 (mod p)；具体求法可以参考初等数论）。Fp 的单位元是1，零元是 0。 这样就可以通过计算K=kG来进行加密。公开的密钥算法都是基于数学上的难题来达到加密的目的的，比如计算两个素数的乘积比较容易，但是要对这个乘积进行因式分解就比较困难了。同样这里也是，已知k和G计算K，相对比较容易，而通过K和G计算k就比较困难，其中G为椭圆曲线上的一个平常点。 哈希二叉树所谓哈希二叉树，又叫做默克尔树，是一种区块中存储交易信息的数据结构。这种数据结构最大的好处就在于，每个交易都可以单独直接删除，只保留这个交易的Hash值即可。这样，对整个区块来说，并没有改变他的密码学安全性和完整性，但是数据量可以大大减小。（Hash值32个字节，而一笔交易一般要400多个字节）。如果一个区块中只有一个交易没有后续交易，那么删除其他所有交易，整个区块的数据量会大大减小。因此，在UTXO的记账模式中，使用默克尔树结构，通常就无需担心数据量一直增长导致数据过大的问题了。 哈希就是把任意数据映射程固定长度的数据的函数，如MD5等。 默克尔树是哈希表的一种拓展。或者说哈希表可以看作一种特殊的默克尔树，即树高为2的多叉默克尔树。默克尔树的叶节点是一个个数据块，有相应的哈希与它对应。然后往上走，把每一个叶节点得到的哈希合并成字符串，在运算这个字符串的哈希，这样就得到了一个子哈希。这样最终推算到根节点。这样当叶节点为单数时，在遇到最后一个叶节点时，会复制该叶节点，然后计算这两个叶节点的哈希合并字符串的哈希，生成子哈希。 默克尔树与哈希表的不同在于，默克尔树可以通过分支验证，而不用下载整个列表。这样就节省搜索耗时和存储资源。]]></content>
      <tags>
        <tag>区块链技术原理，椭圆曲线方程，哈希二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习算法与数据结构]]></title>
    <url>%2F2018%2F03%2F18%2F20180327%2F</url>
    <content type="text"><![CDATA[0. 开始学习《算法》学习算法之前，其实以前看过《算法导论》，但是那本书有太多的证明和运算，看的有点头大，毕竟数学基础比较差，在论坛上，大家都对《算法》这本书推崇备至，一直想要一睹真容，现在终于决定花两个月的时间把这本书读一遍，据说比较适合入门级选手。 1. 第一章 基础下面我会记录比较重要的，并会把练习的代码放在github上，有兴趣的可以看看，虽然代码写的可能比较烂，慢慢进步吧。 第一章的内容主要是讲java语言的基础，我之前没有java语言基础，但是学过C语言和python，对这些基本语法的掌握应该会比较快，所以我在这里会记录一些关于java语言的基础知识点，据书中描述，只要知道这些基本的语法，对书中的算法也可以理解清楚了。 原始数据类型语句：声明、赋值、条件、循环、调用、返回。数组静态方法，函数字符串输入输出数据抽象java语言的标准绘图库StdDraw，因为我是第一次学到，在这里也记一笔。 数据抽象，就是面向对象的编程，重点在于API的设计。 数据类型的值是一组对象的集合，所有操作包括，添加、删除、访问。 背包背包是一种不支持删除元素的集合数据类型。 先进先出的队列后进先出的栈链表链表是一种递归的数据结构， class Node{ int value; Node next; } 链表是一种比较基础的数据结构，通过链表的实现可以构建很多复杂的数据结构。这里基本上是算法第四版的第一章的基本内容，简单的提一下。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>JAVA</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链学习笔记（一）]]></title>
    <url>%2F2018%2F03%2F18%2F20180318%2F</url>
    <content type="text"><![CDATA[0. 计划一年之计在于春，春天到了，给自己定了个小目标，深入学习区块链技术（作为一个业余码农，这个目标其实有点大。。。）。 1. 精通比特币从《精通比特币》这本书开始，这本只有300页不到，但是囊括了比特币技术原理设计到每一个细节，讲的很全面，也很清晰，接下去，我会根据我的理解，讲一下这本书中提及的一些算法的具体内容：比如密码学方面的椭圆曲线方程算法，比如哈希二叉树算法等等。 2.这只是一个开始下面附上我的今年书单： SEO实战密码具体数学，计算机科学基础组合数学python绝技，利用python成为顶级黑客深入理解机器学习应用密码学算法设计与分析基础区块链，原理，设计与应用代码大全2白帽子讲web安全量化投资，以python为工具零起点，python大数据与量化交易python黑帽子，黑客与渗透测试与编程之套深度学习算法实践go语言编程概率论及其应用 量化交易书单中低频量化交易策略研发投资学计量经济学漫步华尔街信号与噪声量化交易，自己动手做算法交易黑盒子，量化交易精要]]></content>
      <tags>
        <tag>书籍</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next+github搭建个人博客]]></title>
    <url>%2F2017%2F08%2F18%2F20180312%2F</url>
    <content type="text"><![CDATA[0.开篇本来只是想找个地方记录每一天学习的内容，花了一段时间寻找合适的平台，但是依然没有找到。看到圈内很多大牛都有自己的博客，也想通过购买域名和服务器搭建自己的博客，这样对于一个菜鸟来说，成本有点高，忽然某一天发现可以通过github构建免费的博客，本篇仅通过参考Devin_的Hexo-Next-主题优化的方法，徒手建立，亲测有效，开启菜鸟之路。 1. 下载安装Hexo和NextHexo依赖Node.js，所以首先需要安装Node.js和npm，我是用的Mac系统，具体的安装方法是通过homebrew进行的，具体代码如下： 安装homebrewruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装node.jsbrew install node 安装hexonpm install -g hexo 相关hexo命令创建相应的博客目录后，就可以通过hexo init命令初始化，得到一篮子文件，开始搭建博客 hexo generate #得到一个静态页面 hexo clean #清除缓存文件 hexo deploy #同步github 主题Next我选择了next主题，也可以选择其他主题，只需要把相应的主题拷贝theme目录下,主题的相关说明文档里面后Next主题的基本操作。 2. 注册github账号注册GitHub账号，创建自己repo，相信每个程序员或伪程序员都知道github，小白可以自行google。 3. 简单设置本部分参考了Mac下利用Hexo+GitHub搭建自己的博客,一步一步操作进行的。 检查SSH key，如果已经有的话，备份一下cd ~/.ssh mkdir key_backup mv id_rsa* key_backup 如果没有，根据下面的命令生成SSH keyssh-keygen -t rsa -C "xxxx@xxxx.com” 将SSH key添加到Github登录到GitHub页面，Account Settings-&gt;SSH Public Keys-&gt;Add another key将生成的key(id_rsa.pub文件）内容copy到输入框中，save。 设置个人信息git config --global user.name "shenjia” git config --global user.email shenjia30615@163.com 修改hexo根目录下_config.yml文件（xxxx为你的github账户名称）deploy: type: github repo: git@github.com:xxxx/xxxx.github.io.git branch: master 提交本地博客到github上就可以了，Hexo博客搭建已经完成了，并且可以git提交到github上，具体的提交通过在博客站点目录输入上面介绍的hexo的三个命令，具体如下，成功之后，通过访问xxxx.github.io就可以访问本博客。 hexo clean && hexo g && hexo d 先写这么多，还学了一些主题优化，后面慢慢加进来。第一次写技术博客，可能条理不清楚，慢慢加油。]]></content>
      <tags>
        <tag>Next</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
